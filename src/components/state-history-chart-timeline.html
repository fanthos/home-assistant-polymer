<link rel='import' href='../../bower_components/polymer/polymer.html'>
<link rel='import' href='./entity/ha-chart-base.html'>

<dom-module id='state-history-chart-timeline'>
  <template>
      <ha-chart-base publish data="[[chartData]]"></ha-chart-base>
  </template>
</dom-module>
<script>

Polymer({
  is: 'state-history-chart-timeline',

  properties: {
    data: {
      type: Object,
      observer: 'dataChanged',
    },

    endTime: {
      type: Object,
    },

    isAttached: {
      type: Boolean,
      value: false,
      observer: 'dataChanged',
    },
  },

  created: function () {
    this.style.display = 'block';
  },

  attached: function () {
    this.isAttached = true;
  },

  dataChanged: function () {
    this.drawChart();
  },

  drawChart: function () {
    var stateHistory = this.data;
    var dataTable;
    var startTime;
    var endTime;

    if (!this.isAttached) {
      return;
    }


    if (!this.isAttached) {
      return;
    }

    if (!stateHistory) {
      // || stateHistory.length === 0) {
      stateHistory = [];
    }

    startTime = new Date(
      stateHistory.reduce(
        function (minTime, stateInfo) {
          return Math.min(minTime, new Date(stateInfo[0].last_changed));
        }, new Date()));

    // end time is Math.max(startTime, last_event)
    endTime = this.endTime || new Date(
      stateHistory.reduce(
        function (maxTime, stateInfo) {
          return Math.max(maxTime,
            new Date(stateInfo[stateInfo.length - 1].last_changed));
        }, startTime));

    if (endTime > new Date()) {
      endTime = new Date();
    }

    dataTable = [];
    // stateHistory is a list of lists of sorted state objects
    stateHistory.forEach(function (stateInfo) {
      var entityDisplay;
      var newLastChanged;
      var prevState = null;
      var prevLastChanged = null;
      var dataRow = [];

      if (stateInfo.length === 0) return;

      entityDisplay = window.hassUtil.computeStateName(stateInfo[0]);

      stateInfo.forEach(function (state) {
        var timeStamp = new Date(state.last_changed);
        if (timeStamp > endTime) {
          // Drop datapoints that are after the requested endTime. This could happen if
          // endTime is 'now' and client time is not in sync with server time.
          return;
        }
        if (prevState !== null && state.state !== prevState) {
          newLastChanged = new Date(state.last_changed);

          dataRow.push([prevState, prevLastChanged, newLastChanged]);

          prevState = state.state;
          prevLastChanged = newLastChanged;
        } else if (prevState === null) {
          prevState = state.state;
          prevLastChanged = new Date(state.last_changed);
        }
      });

      dataRow.push([prevState, prevLastChanged, endTime]);
      dataTable.push({
        data: dataRow,
        label: entityDisplay
      });
    });

    this.chartData = { data: dataTable, type: 'timeline' };
  },
});

</script>
