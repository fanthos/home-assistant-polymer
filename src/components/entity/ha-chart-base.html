<link rel='import' href='../../../bower_components/polymer/polymer.html'>

<dom-module id="ha-chart-base">
  <link rel="import" type="css" href="../../../bower_components/billboard.js/dist/billboard.min.css">
  <template>
    <style>
       :host {
        display: block;
        /* @apply --my-custom-chart-istic-mixin; */
      }
    </style>
    <div id="chartTarget"></div>
  </template>
</dom-module>
<script src="../../../bower_components/d3/d3.js"></script>
<script src="../../../bower_components/d3-gtimeline/dist/d3-gtimeline.js"></script>
<script src="../../../bower_components/billboard.js/dist/billboard.js"></script>
<script>
/* global d3 bb */
  /**
 * Original: d3-gtimeline at Github
 * Modified and rewrited for Home Assistant
 *
 * TODO:
 * ++ shorten title line for small screen
 * .. add highlight for selected item
 * .. Repaint when viewpoint change
 * *. import 'billboard-charts' after it has css fixed
 *
 * xx: fixed
 * ++: workarounded
 */

(function () {
  if (customElements.get('ha-chart-base')) return;
  /**
   * `billboard-charts`
   * Polymer wrapper around billboard.js charting library
   *
   * @customElement
   * @polymer
   */
  class ExtenedChart extends Polymer.Element {
    get chart() {
      return this._chart;
    }
    static get is() { return 'ha-chart-base'; }
    static get properties() {
      return {
        publish: {
          type: Boolean,
          observer: 'onPropsChange'
        },
        data: {
          type: Object,
          observer: 'onPropsChange'
        },
        newData: {
          type: Object,
          observer: 'onNewData'
        },
        selectedElement: {
          type: Object,
          readOnly: true,
          notify: true,
        }
      };
    }
    loaded() {
      this._cssLoaded = true;
      this.onPropsChange();
    }
    onPropsChange() {
      // if (!this._cssLoaded)
      //     return;
      if (!this.publish || !this.data || !this.data.data) return;
      if (this.data.type === 'timeline') {
        this.drawTimeline();
        return;
      }
      this.data.bindto = this.$.chartTarget;
      if (!this.data.data.onclick) {
        // debugger;
        this.data.data.onclick = (dataPoint) => {
          this._setSelectedElement(dataPoint);
        };
      }
      if (!this._chart) {
        this._chart = bb.generate(this.data);
        if (this.newData) {
          this.onNewData();
        }
      } else {
        this._chart = bb.generate(this.data);
      }
    }
    onNewData() {
      if (this.newData && this._chart) {
        this._chart.load(this.newData);
      }
    }
    drawTimeline() {
      var chart = d3.timeline();
      chart.knownColor = {
        on: d3.hcl(0, 95, 75),
        active: d3.hcl(15, 90, 75),
        off: d3.hcl(120, 90, 75),
        deactive: d3.hcl(150, 90, 75)
      };
      d3.select(this.$.chartTarget).datum(this.data.data).call(chart);
    }
  }
  customElements.define(ExtenedChart.is, ExtenedChart);
}());
</script>
