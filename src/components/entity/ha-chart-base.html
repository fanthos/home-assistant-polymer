<link rel='import' href='../../../bower_components/polymer/polymer.html'>

<dom-module id="ha-chart-base">
  <link rel="import" type="css" href="../../../bower_components/billboard.js/dist/billboard.min.css">
  <template>
    <style>
       :host {
        display: block;
        /* @apply --my-custom-chart-istic-mixin; */
      }
      .tooltip {
        position: absolute;
        padding: 5px;
        background: white;
        border: 1px solid #AAA;
        border-radius: 2px;
        pointer-events: none;
        z-index: 32767;
      }
      #chartTarget {
        position: relative;
      }
    </style>
    <div id="chartTarget"></div>
  </template>
  <script src="../../../bower_components/d3/d3.min.js"></script>
  <script src="../../../bower_components/billboard.js/dist/billboard.min.js"></script>

</dom-module>
<script>
/* global d3 bb */
  /**
 * Original: d3-gtimeline at Github
 * Modified and rewrited for Home Assistant
 *
 * TODO:
 * ++ shorten title line for small screen
 * .. add highlight for selected item
 * .. Repaint when viewpoint change
 * *. import 'billboard-charts' after it has css fixed
 *
 * xx: fixed
 * ++: workarounded
 */


(function () {
  function lf(obj, val, args1) {
    if (args1.length) {
      return [obj, args1[0]];
    }
    return [val, val];
  }

  var tooltip = function (domobj, htmlFunc) {
    if (!domobj) {
      domobj = 'body';
    }

    var selection = d3.select(domobj).append('div')
      .attr('class', 'tooltip')
      .style('opacity', 0);

    selection.show = function (d, i, r) {
      selection.transition()
        .duration(100)
        .style('opacity', 0.95);
      var datay = r[0].attributes['data-y'].value;
      var node1 = selection.node();
      var width1 = node1.clientWidth;
      var x1 = parseInt(r[0].attributes.x.value);
      var parentWidth = node1.parentNode.clientWidth;
      selection.html(htmlFunc.apply(null, [d, i, r]))
        .style('left', 'unset')
        .style('right', 'unset');
      if (x1 + width1 + 10 > parentWidth) {
        selection.style('right', '10px')
          .style('top', datay + 'px');
      } else {
        selection.style('left', x1 + 'px')
          .style('top', datay + 'px');
      }
    };

    selection.hide = function () {
      selection.transition()
        .duration(100)
        .style('opacity', 0);
    };

    return selection;
  };

  var none = 0;
  var right = 1;
  var left = 2;

  function timelineAxis(orient, scale) {
    var colors = ['#FFF', '#EEE'];
    var padding = 5;
    var range;
    var lineColor = '#AAA';
    var trim = 40;
    var width = 100;

    function maxTextWidth(selection) {
      return d3.max(selection.nodes().map(d => d.getComputedTextLength()));
    }

    function trimLongString(value) {
      return function (d) {
        return d.length > value ? d.slice(0, value - 1) + '\u2026' : d;
      };
    }

    function axis(selection) {
      var domain = scale.domain();
      var colorscale = d3.scaleOrdinal(colors);
      var labels = trimLongString(trim);
      var row = selection.selectAll('.row').data(domain, scale).order();
      var rowEnter = row.enter().append('g').attr('class', 'row');
      var rowExit = row.exit();
      var offset;

      row = row.merge(rowEnter)
        .attr('transform', d => 'translate(0,' + scale(d) + ')');

      rowExit.remove();

      rowEnter.append('rect')
        .attr('y', 0.5)
        .attr('width', width)
        .attr('height', scale.bandwidth())
        .attr('stroke', lineColor)
        .attr('stroke-width', 0.75)
        .attr('fill', colorscale);  // should be re-done if domain changed?

      if (orient !== none) {
        var texts = row.select('text');
        texts = texts.merge(rowEnter.append('text')
          .attr('y', scale.bandwidth() / 2)
          .attr('dy', '0.32em')
        ).text(labels);

        var textWidthLimit = width * 0.2;
        offset = maxTextWidth(texts) + padding + padding;
        offset = Math.min(textWidthLimit, offset);
        offset = orient === right ? width - offset : offset;

        range = orient === right ? [0, offset] : [offset, width];

        texts
          .attr('text-anchor', orient === right ? 'start' : 'end')
          .attr('dx', orient === right ? padding : -padding)
          .attr('x', offset);
      } else {
        range = [0, width];
      }

      selection.append('path')
        .attr('stroke', lineColor)
        .attr('d', 'M' + (offset + 0.5) + ',0.5V' + scale.range()[1]);
    }

    axis.draw_ticks = function (selection, ticks) {
      selection.selectAll('.row').select('path')
        .attr('d', ticks.map(
          t => 'M' + t + ',' + 1 + 'v' + (scale.bandwidth() - 1)).join(''));
    };

    var y;
    axis.scale = (...args) => { [y, scale] = lf(axis, scale, args); return y; };
    axis.width = (...args) => { [y, width] = lf(axis, width, args); return y; };
    axis.colors = (...args) => { [y, colors] = lf(axis, colors, args); return y; };
    axis.padding = (...args) => { [y, padding] = lf(axis, padding, args); return y; };
    axis.range = (...args) => { [y, range] = lf(axis, range, args); return y; };
    axis.trim = (...args) => { [y, trim] = lf(axis, scale, args); return y; };

    // axis.scale = function (_) { return arguments.length ? (scale = _, axis) : scale };
    // axis.width = function (_) { return arguments.length ? (width = _, axis) : width };
    // axis.colors = function (_) { return arguments.length ? (colors = _, axis) : colors };
    // axis.padding = function (_) { return arguments.length ? (padding = _, axis) : padding };
    // axis.range = function (_) { return arguments.length ? (range = _, axis) : range };
    // axis.trim = function (_) { return arguments.length ? (trim = _, axis) : trim };

    return axis;
  }

  function timelineAxisLeft(scale) {
    return timelineAxis(left, scale);
  }

  function timelineAxisRight(scale) {
    return timelineAxis(right, scale);
  }

  function timelineAxisNone(scale) {
    return timelineAxis(none, scale);
  }

  function durationFormat(seconds) {
    function round10(x) {
      return Math.round(x * 10) / 10;
    }
    var cutoff = 2;
    var ret;
    if (seconds < cutoff * 60) {
      ret = seconds + 's';
    } else if (seconds < cutoff * 60 * 60) {
      ret = round10(seconds / 60) + ' min';
    } else if (seconds < cutoff * 60 * 60 * 24) {
      ret = round10(seconds / 3600) + ' hours';
    } else if (seconds < cutoff * 3600 * 24 * 30) {
      ret = round10(seconds / 86400) + ' day(s)';
    } else if (seconds < cutoff * 3600 * 24 * 365) {
      ret = round10(seconds / (86400 * 30)) + ' month(s)';
    } else {
      ret = round10(seconds / (86400 * 365)) + ' year(s)';
    }
    return ret;
  }

  function getFontSize(element) {
    var style = window.getComputedStyle(element, null).getPropertyValue('font-size');
    return parseFloat(style);
  }

  var timeline = function () {
    function f(value) {
      return function (d) {
        return value === undefined ? d : d[value];
      };
    }

    function translate(x, y) {
      return 'translate(' + x + ',' + y + ')';
    }

    var padding = 5;
    var reversed = false;
    var today = false;
    var dates;
    var constWidth;
    var duration = 0;
    var names = f(0);
    var starts = f(1);
    var ends = f(2);

    function tooltipHtml(d) {
      // Format date for human
      var seconds = (ends(d) - starts(d)) / 1000;
      var dateFormat;
      if (seconds < 3600 * 18) {
        dateFormat = '%H:%M:%S';
      } else if (seconds < 86400 * 7) {
        dateFormat = '%m-%d %H:%M';
      } else {
        dateFormat = '%Y-%m-%d';
      }
      var format = x => d3.timeFormat(dateFormat)(d3.isoParse(x));
      return '<b>' + names(d) + '</b>' +
        '<hr style="margin: 2px 0 2px 0">' +
        format(starts(d)) + ' - ' + format(ends(d)) + '<br>' +
        durationFormat(seconds);
    }

    function chart(selection) {
      // Known colors for static data,
      // should add for very common state string manually.
      const colorKnown = {
        on: d3.hcl(0, 95, 75),
        active: d3.hcl(15, 90, 75),
        off: d3.hcl(120, 90, 75),
        deactive: d3.hcl(150, 90, 75),
      };
      // Distribute the color data like complete binary tree
      function getColorRange(x) {
        if (x === 0) return 0;
        if (x === 1) return 0.5;
        var y = Math.floor(Math.log2(x));
        var e = 2 ** y;
        var n = x - e;
        var a;
        if (y % 2 === 1) {
          if (n % 2 === 0) {
            a = n + 1;
          } else {
            a = n + e;
          }
        } else {
          // eslint-disable-next-line no-lonely-if
          if (n % 2 === 0) {
            a = e - n - 1;
          } else {
            a = (e + e) - n;
          }
        }
        return a / (e + e);
      }
      var colorDict = new Map();
      var colorIndex = 0;
      // Custom color assign
      function getColor(name) {
        var ret = colorKnown[name];
        if (ret === undefined) {
          ret = colorDict.get(name);
        }
        if (ret === undefined) {
          var h1 = getColorRange(colorIndex);
          ret = d3.hcl(h1 * 360, 60, 75);
          colorIndex++;
          colorDict.set(name, ret);
        }
        return ret;
      }
      var dataTable = selection.datum();
      var rows = d3.map(dataTable, x => x.label).keys();

      dates = dates ||
        [d3.min(dataTable, d => d.start), d3.max(dataTable, d => d.end)];

      selection.each(function (data) {
        var width = constWidth || this.getBoundingClientRect().width;
        var height = rows.length * (getFontSize(this) + (4 * padding));
        var yScale = d3.scaleBand().domain(rows).range([0, height]); // .padding(0.1),
        var xScale = d3.scaleTime().domain(dates);
        var yAxis;
        if (data.length === 1) {
          yAxis = timelineAxisNone(yScale).width(width);
        } else {
          yAxis = (reversed ? timelineAxisRight : timelineAxisLeft)(yScale).width(width);
        }
        d3.select(this).select('div').remove();
        d3.select(this).select('svg').remove();
        var svg = d3.select(this).append('svg').attr('class', 'timeline');
        var tip = new tooltip(this, tooltipHtml);

        svg.attr('width', width);
        svg.attr('height', height + 20); // margin.bottom

        var g = svg.append('g');
        g.selectAll('g.task').data(data).exit().remove();

        var yGroup = g.append('g')
          .attr('class', 'y axis')
          .call(yAxis);

        var range = yAxis.range();
        xScale.range([range[0], range[1]]).clamp(true);
        var xAxis = d3.axisBottom(xScale);
        var xGroup = g.append('g')
          .attr('class', 'x axis')
          .attr('transform', translate(0, height))
          .call(xAxis);

        xGroup.select('.domain').remove();
        xGroup.selectAll('.tick line')
          .attr('stroke', '#AAA')
          .attr('stroke-width', 0.75)
          .attr('y1', -height);

        var ticks = xScale.ticks().map(xScale);
        yGroup.call(yAxis.draw_ticks, ticks);

        var padding2 = padding + padding;
        var yScaleList = data.map(x => yScale(x.label) + padding);
        var yScaleBandwidth = yScale.bandwidth() - padding2;

        g.append('g')
          .selectAll('g')
          .data(data)
          .enter()
          .append('g')
          .attr('transform', d => 'translate(0, ' + yScale(d.label) + ')')
          .classed('task', true)
          .each((data1, i1, node1) => {
            d3.select(node1[i1]).selectAll('rect').data(d => d.data).enter()
              .each((data2, i2, n) => {
                var g2 = d3.select(n[i2]);
                var bgColor = getColor(names(data2));
                var xStart = xScale(starts(data2));
                var xWidth = xScale(ends(data2)) - xStart;
                g2.append('rect')
                  .attr('y', 5)
                  .attr('x', xStart)
                  .attr('width', xWidth + 0.5)
                  .attr('height', yScaleBandwidth)
                  .attr('data-y', yScaleList[i1] + yScaleBandwidth)
                  .on('mouseover', tip.show)
                  .on('mouseout', tip.hide)
                  .attr('fill', bgColor);
                if (xWidth > padding2) {
                  // Hide text for small node
                  var str1 = names(data2);
                  var t = g2
                    .append('text')
                    .attr('x', xStart)
                    .attr('y', 5)
                    .attr('dx', padding)
                    .attr('dy', (yScaleBandwidth / 2) + padding)
                    .attr('text-anchor', 'start')
                    .attr('fill', 'black')
                    .attr('pointer-events', 'none')
                    .text(str1);
                  if (xWidth - padding < t.node().getComputedTextLength()) {
                    t.remove();
                  }
                }
              });
          });
        // if (today)
        //   selection.append('path')
        //     .attr('stroke', 'red')
        //     .attr('d', 'M' + xScale(new Date) + ',0.5V' + height);
      });
    }

    var y;
    chart.dates = (...args) => { [y, dates] = lf(chart, dates, args); return y; };
    chart.width = (...args) => { [y, constWidth] = lf(chart, constWidth, args); return y; };
    chart.today = (...args) => { [y, today] = lf(chart, today, args); return y; };
    chart.padding = (...args) => { [y, padding] = lf(chart, padding, args); return y; };
    chart.reversed = (...args) => { [y, reversed] = lf(chart, reversed, args); return y; };
    chart.duration = (...args) => { [y, duration] = lf(chart, duration, args); return y; };

    return chart;
  };

  var x = {};
  x.chartTimeline = timeline;
  x.tooltip = tooltip;
  x.timelineAxisLeft = timelineAxisLeft;
  x.timelineAxisRight = timelineAxisRight;
  x.durationFormat = durationFormat;

  Object.assign(d3, x);
}());

(function () {
  if (customElements.get('ha-chart-base')) return;
  /**
   * `billboard-charts`
   * Polymer wrapper around billboard.js charting library
   *
   * @customElement
   * @polymer
   */
  class ExtenedChart extends Polymer.Element {
    get chart() {
      return this._chart;
    }
    static get is() { return 'ha-chart-base'; }
    static get properties() {
      return {
        publish: {
          type: Boolean,
          observer: 'onPropsChange'
        },
        data: {
          type: Object,
          observer: 'onPropsChange'
        },
        newData: {
          type: Object,
          observer: 'onNewData'
        },
        selectedElement: {
          type: Object,
          readOnly: true,
          notify: true,
        }
      };
    }
    loaded() {
      this._cssLoaded = true;
      this.onPropsChange();
    }
    onPropsChange() {
      // if (!this._cssLoaded)
      //     return;
      if (!this.publish || !this.data || !this.data.data) return;
      if (this.data.type === 'timeline') {
        this.drawTimeline();
        return;
      }
      this.data.bindto = this.$.chartTarget;
      if (!this.data.data.onclick) {
        // debugger;
        this.data.data.onclick = (dataPoint) => {
          this._setSelectedElement(dataPoint);
        };
      }
      if (!this._chart) {
        this._chart = bb.generate(this.data);
        if (this.newData) {
          this.onNewData();
        }
      } else {
        this._chart = bb.generate(this.data);
      }
    }
    onNewData() {
      if (this.newData && this._chart) {
        this._chart.load(this.newData);
      }
    }
    drawTimeline() {
      var chart = d3.chartTimeline();
      d3.select(this.$.chartTarget).datum(this.data.data).call(chart);
    }
  }
  customElements.define(ExtenedChart.is, ExtenedChart);
}());
</script>
