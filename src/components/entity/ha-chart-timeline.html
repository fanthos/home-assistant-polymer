<link rel='import' href='../../../bower_components/polymer/polymer.html'>
<link rel='import' href='../../../bower_components/d3-element/d3-element.html'>

<dom-module id='ha-chart-timeline'>
  <template>
    <div id='hachart' style='position:relative;overflow:visible'></div>
  </template>
</dom-module>
<script>
  /**
 * TODO:
 * xx fix tooltip
 * 2. fix history chart for single sensor
 * 3. add d3 to bower
 * 4. add support for static color text
 * 5. fix tooltip date
 * 6. shorten title line for small screen
 */
(function () {
  var css = 'position:absolute;padding: 5px;background: white;'
    +'border:1px solid #AAA;border-radius: 2px;'
    + 'pointer-events: none;z-index:32767';
var tooltip = function (domobj, html_func) {

  if(!domobj) {
    domobj = 'body';
  }

  var selection = d3.select(domobj).append('div')
    .attr('style', css)
    .style('opacity', 0);

  selection.show = function (d, i, r) {
    selection.transition()
      .duration(100)
      .style('opacity', .95);
    selection.html(html_func.apply(null, arguments))
      .style('left', 'unset')
      .style('right', 'unset');
    var node1 = selection.node();
    var width1 = node1.clientWidth;
    var x1 = parseInt(r[0].attributes['x'].value);
    var parentWidth = node1.parentNode.clientWidth;
    if(x1 + width1 + 10 > parentWidth){
      selection.style('right', '10px' )
        .style('top', r[0].attributes['data-y'].value + 'px');
    } else {
      selection.style('left', x1 + 'px')
        .style('top', r[0].attributes['data-y'].value + 'px');
    }
  };

  selection.hide = function (d) {
    selection.transition()
      .duration(100)
      .style('opacity', 0);
  };

  return selection;
};

function identity(x) {
  return x;
}

var right = 1;
var left = 2;

function timelineAxis(orient, scale) {
  var colors = ['#FFF', '#EEE'],
    padding = 5,
    range,
    line_color = '#AAA',
    trim = 40,
    width = 100;

  function max_text_width(selection) {
    return d3.max(selection.nodes().map(d => d.getComputedTextLength()));
  }

  function trim_long_string(value) {
    return function (d) {
      return d.length > value ? d.slice(0, value - 1) + '\u2026' : d
    }
  }

  function axis(selection) {
    var domain = scale.domain(),
      tip = tooltip(false, identity),
      colorscale = d3.scaleOrdinal(colors),
      invertscale = d3.scaleOrdinal(colors.reverse()),
      labels = trim_long_string(trim),
      row = selection.selectAll('.row').data(domain, scale).order(),
      rowEnter = row.enter().append('g').attr('class', 'row'),
      rowExit = row.exit(),
      texts = row.select('text');

    row = row.merge(rowEnter)
      .attr('transform', (d) => 'translate(0,' + scale(d) + ')');

    rowExit.remove();

    rowEnter.append('rect')
      .attr('y', 0.5)
      .attr('width', width)
      .attr('height', scale.bandwidth())
      .attr('stroke', line_color)
      .attr('stroke-width', 0.75)
      .attr('fill', colorscale);  // should be re-done if domain changed?

    //rowEnter.append('path').attr('stroke', invertscale);

    texts = texts.merge(rowEnter.append('text')
      .attr('y', scale.bandwidth() / 2)
      .attr('dy', '0.32em')
      .on('mouseover', function (d) {
        if (d3.select(this).text() != d)
          tip.show(d);
      })
      .on('mouseout', tip.hide))
      .text(labels);

    var offset = max_text_width(texts) + 2 * padding;
    offset = orient === right ? width - offset : offset;

    range = orient === right ? [0, offset] : [offset, width];

    texts
      .attr('text-anchor', orient === right ? 'start' : 'end')
      .attr('dx', orient === right ? padding : -padding)
      .attr('x', offset);

    selection.append('path')
      .attr('stroke', line_color)
      .attr('d', 'M' + (offset + .5) + ',0.5V' + scale.range()[1]);
  }

  axis.draw_ticks = function (selection, ticks) {
    selection.selectAll('.row').select('path')
      .attr('d', ticks.map(
        (t) => 'M' + t + ',' + 1 + 'v' + (scale.bandwidth() - 1)).join(''));
  };

  axis.scale = function (_) { return arguments.length ? (scale = _, axis) : scale };
  axis.width = function (_) { return arguments.length ? (width = _, axis) : width };
  axis.colors = function (_) { return arguments.length ? (colors = _, axis) : colors };
  axis.padding = function (_) { return arguments.length ? (padding = _, axis) : padding };
  axis.range = function (_) { return arguments.length ? (range = _, axis) : range };
  axis.trim = function (_) { return arguments.length ? (trim = _, axis) : trim };

  return axis;
}

function timelineAxisLeft(scale) {
  return timelineAxis(left, scale);
}

function timelineAxisRight(scale) {
  return timelineAxis(right, scale);
}

//var moment = require('moment'),
//    d3 = require('d3');

//import { createDuration } from 'moment/src/lib/duration/create';
//import {humanize} from 'moment/src/lib/duration/humanize';

function durationFormat(start, end) {
  //return createDuration(end-start).humanize();
  //if(moment)
  //	return moment.duration(end-start).humanize();

  var seconds = d3.timeSecond.count(start, end),
    cut_off = 2;
  if (seconds < cut_off * 60)
    return seconds + 's'
  else if (seconds < cut_off * 60 * 60)
    return d3.timeMinute.count(start, end) + ' min'
  else if (seconds < cut_off * 60 * 60 * 24)
    return d3.timeHour.count(start, end) + ' hours'
  else if (seconds < cut_off * 3600 * 24 * 30)
    return d3.timeDay.count(start, end) + ' day(s)'
  else if (seconds < cut_off * 3600 * 24 * 365)
    return d3.timeMonth.count(start, end) + ' month(s)'
  else
    return d3.timeYear.count(start, end) + ' year(s)';

}

var google_colors = [
  '#4285f4', '#db4437', '#f4b400', '#0f9d58', '#ab47bc', '#5e97f5', '#e06055',
  '#f5bf26', '#33ab71', '#b762c6', '#00acc1', '#ff855f', '#9e9d24', '#26b8ca', '#ff7043'];

function getFontSize(element) {
  var style = window.getComputedStyle(element, null).getPropertyValue('font-size');
  return parseFloat(style);
}

function isBright(c) {
  return (c.r * 0.299 + c.g * 0.587 + c.b * 0.114) > 165;
  // luma_BT709 original is 186, but I prefer that value
}

function textColor(value) {
  return isBright(d3.color(value)) ? 'black' : 'white';
}

function translate(x, y) {
  return 'translate(' + x + ',' + y + ')';
}

var timeline = function () {
  function f(value) {
    return function (d) {
      return value === undefined ? d : d[value];
    }
  }

  var colors = google_colors,
    padding = 5,
    reversed = false,
    today = false,
    dates,
    const_width,
    duration = 0,
    names = f(0),
    starts = f(1),
    ends = f(2);

  var color_index = 0;
  var color_dict = new Map();
  function getColor(name, data, cScale) {
    if (!data) {
      return 'black';
    }
    if (!isNaN(data.min)) {
      var val1 = parseInt(name);
      var val2 = (val1 - data.min) / (data.max - data.min) * 240;
      return 'hsl(' + val2 + ', 85%, 65%)';
    } else {
      var ret = color_dict.get(name);
      if (ret === undefined) {
        ret = google_colors[color_index];
        color_index++;
        color_dict.set(name, ret);
      }
      return ret;
    }
  }

  function chart(selection) {
    var
      dataTable = selection.datum(),
      rows = d3.map(dataTable, x => x.label).keys(),
      cScale = d3.scaleOrdinal(colors);

    dates = dates ||
      [d3.min(dataTable, d => d.start), d3.max(dataTable, d => d.end)];
    //dates = 

    selection.each(function (data) {
      var width = const_width || this.getBoundingClientRect().width,
        height = rows.length * (getFontSize(this) + 4 * padding),
        yScale = d3.scaleBand().domain(rows).range([0, height]), //.padding(0.1),
        xScale = d3.scaleTime().domain(dates),
        yAxis = (reversed ? timelineAxisRight : timelineAxisLeft)(yScale).width(width);
      d3.select(this).select('div').remove();
      d3.select(this).select('svg').remove();
      var svg = d3.select(this).append('svg').attr('class', 'timeline');
      var tip = new tooltip(this, tooltip_html);

      svg.attr('width', width);
      svg.attr('height', height + 20); // margin.bottom

      var g = svg.append('g');
      g.selectAll('g.task').data(data).exit().remove();

      var yGroup = g.append('g')
        .attr('class', 'y axis')
        .call(yAxis);

      var range = yAxis.range();
      //xScale.range([range[0]+padding, range[1]-padding]).clamp(true);
      xScale.range([range[0], range[1]]).clamp(true);
      var xAxis = d3.axisBottom(xScale);
      var xGroup = g.append('g')
        .attr('class', 'x axis')
        .attr('transform', translate(0, height))
        .call(xAxis);

      xGroup.select('.domain').remove();
      xGroup.selectAll('.tick line').attr('stroke', '#AAA');

      var ticks = xScale.ticks().map(xScale);
      yGroup.call(yAxis.draw_ticks, ticks);

      var padding2 = padding + padding;
      var yScaleList = data.map(x => yScale(x.label) + padding);
      var yScaleBandwidth = yScale.bandwidth() - padding2;


      var tasks = g.append('g')
        .selectAll('g')
        .data(data)
        .enter().append('g')
        .attr('transform', d => 'translate(0, ' + yScale(d.label) + ')')
        .classed('task', true)
        .each((d1, i1, n) => {
          var cScale;
          if(!isNaN(d1.min)) {
            cScale = d3.scaleLinear().domain([d1.min,d1.max]).range([0, 270]);
          } else {
            cScale = getColor;
          }
          d3.select(n[i1]).selectAll('rect')
            .data(d => d.data).enter().each((d2, i, n) => {
              g2 = d3.select(n[i]);
              var bgColor = d3.hcl(cScale(names(d2)), 100, 75);//getColor(names(d2), d1, cScale);
              var xStart = xScale(starts(d2));
              var xWidth = xScale(ends(d2)) - xStart;
              g2.append('rect')
                .attr('y', 5)
                .attr('x', xStart)
                .attr('width', xWidth + 0.5)
                .attr('height', yScaleBandwidth)
                .attr('data-y', yScaleList[i1] + yScaleBandwidth)
                .on('mouseover', tip.show)
                .on('mouseout', tip.hide)
                .attr('fill', bgColor);
              if(xWidth > padding2) {
                var str1 = names(d2);
                var t = g2
                  .append('text')
                  .attr('x', xStart)
                  .attr('y', 5)
                  .attr('dx', padding)
                  .attr('dy', yScaleBandwidth / 2 + padding)
                  .attr('text-anchor', 'start')
                  .attr('fill', 'black')
                  .attr('pointer-events', 'none')
                  .text(str1);
                if(xWidth - padding < t.node().getComputedTextLength()) {
                  t.remove();
                }
              }
          });
        });
      return;

      tasks
        //.transition().duration(duration)
        .attr('transform', d => translate(xScale(starts(d)), yScale(label)))
        .selectAll('rect')
        .attr('width', d => xScale(ends(d)) - xScale(starts(d)))
        .on('start', trim_text);

      if (today)
        selection.append('path')
          .attr('stroke', 'red')
          .attr('d', 'M' + xScale(new Date) + ',0.5V' + height);

    });
  }

  //chart.axis     = function(_) { return arguments.length? (axis  = _, chart): axis ; };
  chart.dates = function (_) { return arguments.length ? (dates = _, chart) : dates; };
  chart.width = function (_) { return arguments.length ? (const_width = _, chart) : const_width; };
  chart.today = function (_) { return arguments.length ? (today = _, chart) : today; };
  chart.colors = function (_) { return arguments.length ? (colors = _, chart) : colors; };
  chart.padding = function (_) { return arguments.length ? (padding = _, chart) : padding; };
  chart.reversed = function (_) { return arguments.length ? (reversed = _, chart) : reversed; };
  chart.duration = function (_) { return arguments.length ? (duration = _, chart) : duration; };

  return chart;

  function tooltip_html(d, i) {
    var format = (d) => d3.timeFormat('%Y-%m-%d')(d3.isoParse(d));
    //var format = d3.isoParse.wrap(d3.timeFormat('%Y-%m-%d'));
    //        var format = compose(d3.isoParse, d3.timeFormat('%Y-%m-%d'));
    return '<b>' + names(d) + '</b>' +
      '<hr style="margin: 2px 0 2px 0">' +
      format(starts(d)) + ' - ' + format(ends(d)) + '<br>' +
      durationFormat(starts(d), ends(d));
  }
};

var x = {};
x.timeline = timeline;
x.tooltip = tooltip;
x.timelineAxisLeft = timelineAxisLeft;
x.timelineAxisRight = timelineAxisRight;
x.durationFormat = durationFormat;

Object.assign(d3, x);
})();

Polymer({
  is: 'ha-chart-timeline',

  properties: {
    data: {
      type: Object,
      observer: 'dataChanged',
    },

    isAttached: {
      type: Boolean,
      value: false,
      observer: 'dataChanged',
    },
  },

  created: function () {
    this.style.display = 'block';
  },

  attached: function () {
    this.isAttached = true;
  },

  dataChanged: function () {
    this.drawChart();
  },

  drawChart: function () {
    var root = Polymer.dom(this);
    var stateHistory = this.data;
    var chart;
    var dataTable;
    var startTime;
    var endTime;
    var numTimelines;
    var format;
    var daysDelta;

    if (!this.isAttached) {
      return;
    }


    if (!this.isAttached) {
      return;
    }

    while (root.node.lastChild) {
      root.node.removeChild(root.node.lastChild);
    }

    if (!stateHistory || stateHistory.length === 0) {
      return;
    }

    startTime = new Date(
      stateHistory.reduce(
        function (minTime, stateInfo) {
          return Math.min(minTime, new Date(stateInfo[0].last_changed));
        }, new Date()));

    // end time is Math.max(startTime, last_event)
    endTime = new Date(
      stateHistory.reduce(
        function (maxTime, stateInfo) {
          return Math.max(maxTime,
            new Date(stateInfo[stateInfo.length - 1].last_changed));
        }, startTime));

    if (endTime > new Date()) {
      endTime = new Date();
    }
    format = 'H:mm';
    daysDelta = (endTime - startTime) / (24 * 3600 * 1000);
    // Avoid rounding up when the API returns a few extra seconds.
    if (daysDelta > 30.1) {
      format = 'MMM d';
    } else if (daysDelta > 3.1) {
      format = 'EEE, MMM d';
    } else if (daysDelta > 1.1) {
      format = 'EEE, MMM d, H:mm';
    }

    numTimelines = 0;

    dataTable = [];
    // stateHistory is a list of lists of sorted state objects
    stateHistory.forEach(function (stateInfo) {
      var entityDisplay;
      var newLastChanged;
      var prevState = null;
      var prevLastChanged = null;
      var dataRowItem = {};
      var dataRow = [];
      var minData;
      var maxData;
      var lastState = stateInfo[0].state;
      if (isFinite(lastState)) {
        minData = maxData = parseFloat(lastState);
      } else {
        minData = maxData = NaN;
      }

      dataRowItem['data'] = dataRow;

      if (stateInfo.length === 0) return;

      entityDisplay = window.hassUtil.computeStateName(stateInfo[0]);

      stateInfo.forEach(function (state) {
        var timeStamp = new Date(state.last_changed);
        if (timeStamp > endTime) {
          // Drop datapoints that are after the requested endTime. This could happen if
          // endTime is 'now' and client time is not in sync with server time.
          return;
        }
        if (prevState !== null && state.state !== prevState) {
          newLastChanged = new Date(state.last_changed);

          dataRow.push([prevState, prevLastChanged, newLastChanged]);

          prevState = state.state;
          prevLastChanged = newLastChanged;
          if (!isNaN(minData)) {
            var v = parseFloat(prevState);
            if (isFinite(v)) {
              if (minData > v) {
                minData = v;
              }
              if (maxData < v) {
                maxData = v;
              }
            } else {
              minData = maxData = NaN;
            }
          }
        } else if (prevState === null) {
          prevState = state.state;
          prevLastChanged = new Date(state.last_changed);
        }
      });

      dataRow.push([prevState, prevLastChanged, endTime]);
      dataTable.push({
        data: dataRow, min: minData, max: maxData,
        start: new Date(stateInfo[0].last_changed),
        end: endTime, label: entityDisplay
      });
      numTimelines++;
    });

    var chart = d3.timeline();

    d3.select(this.$.hachart).datum(dataTable).call(chart);
    return;
  },
});

</script>